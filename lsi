#!/usr/bin/env python3
"""ls command alternative.
Output is either cleanly formatted table or
string of null terminated file names parseable by xargs command.
Default behaviour is to show only non-hidden files and directories of
directory passed or current directory if no directory is given, in table format.
Learn more by passing -h or --help option.
    NOTE: requires python v3+ (tested on v3.6); written for UNIX like OS
REAL Programmers don't need comments, for them the code itself is obvious,
but if you aren't one of them, here you go.
"""


import argparse
import os
import sys

# get size of the terminal for output in table format
terminalRowSize, terminalColumnSize = os.popen('stty size', 'r').read().split()

parser = argparse.ArgumentParser(description=
"""ls command alternative.
Output is either cleanly formatted table or
string of null terminated file names parseable by xargs command.
Default behaviour is to show only non-hidden files and directories of
directory passed or current directory if no directory is given, in table format.
""")

outputFormat = parser.add_mutually_exclusive_group();
outputFormat.add_argument("-t",action="store_true",
help="output in table format; this is default")
outputFormat.add_argument("-1", dest="one", action="store_true",
help="output on file per line")
outputFormat.add_argument('-x','--xargs', action="store_true",
help="""output will be string of null terminated file names;
can be used as input to other commands like xargs;
absense of this option makes output to be a table, which is default""")

group1 = parser.add_mutually_exclusive_group()
group1.add_argument("-n", "--non-hidden", action='store_true', dest="non_hidden",
help="""show files and/or directories with names that does
not start with a dot; this is default""")
group1.add_argument("-i", "--hidden", action='store_true',
help="show files and/or directories with names starting with a dot")
group1.add_argument("-a", "--include-hidden", action='store_true', dest="include_hidden",
help="show all files and/or directories")

group2 = parser.add_mutually_exclusive_group()
group2.add_argument("-d", "--only-dir", action="store_true", dest="only_dir",
help="show directories only and not regular file")
group2.add_argument("-f", "--only-files", action="store_true", dest="only_files",
help="show only regular files and not directories")

parser.add_argument("files", metavar="FILE", nargs='*',
help="""space separated list of any numbers of files and/or directories;
if not given, current directory will be assumed""")

parser.add_argument("-v", "--version",
help="output version information and exit", action="store_true")

args = parser.parse_args()

# non-hidden is default option
if not args.non_hidden and not args.hidden and not args.include_hidden:
    args.non_hidden = True


"""function declarations STARTS here"""

def version():
    """Print version, license and exit"""
    if args.version:
        print(
"""lsi version 1.1.2

Copyright (c) 2017 js-d-coder (www.github.com/js-d-coder)

This project is free software released under the MIT/X11 license:

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
""")
        sys.exit(0)


def createFileList(dirname):
    """create list of files in given directory based on various options"""
    files = []
    dirs = []
    all_files = os.listdir(dirname)

    if args.non_hidden:
        files = [file for file in all_files if not os.path.isdir(dirname + "/" + file) and file[0] != '.' ]
        dirs = [file+"/" for file in all_files if os.path.isdir(dirname + "/" + file) and file[0] != '.' ]
    elif args.hidden:
        files = [file for file in all_files if not os.path.isdir(dirname + "/" + file) and file[0] == '.' ]
        dirs = [file+"/" for file in all_files if os.path.isdir(dirname + "/" + file) and file[0] == '.' ]
    else:
        files = [file for file in all_files if not os.path.isdir(dirname + "/" + file)]
        dirs = [file+"/" for file in all_files if os.path.isdir(dirname + "/" + file)]
    if args.only_files:
        return files
    elif args.only_dir:
        return dirs
    else:
        return files + dirs


def xargsInput():
    """create string of null terminated file names for processing by xargs command"""
    outputString = ""
    for file in args.files:
        if not os.path.isdir(file):
            outputString += file + "\0"
        else:
            for inode in createFileList(file):
                outputString += file + "/" + inode + "\0"
    return outputString


def columnOutput(printFunc):
    """function when requested output is either table or one-file-per-line.
    Note the use of printFunc; it substitue prettyPrint function for tabular output,
    or oneFilePerLine function to output one file per line."""
    global didErrorOccur
    moreThanOneArg = 0
    for file in args.files:
        """keep processing next file in the files list even if error occur.
        if error occur print the error and process next file in the files list.
        didErrorOccur is used as a flag whether error occur or not"""
        try:
            if not os.path.exists(file):
                raise FileNotFoundError("{}: cannot access '{}': no such file or directory".format(os.path.basename(sys.argv[0]), file))
            elif not os.path.isdir(file):
                if moreThanOneArg: print()
                print(file)
            else:
                if moreThanOneArg: print()
                if len(args.files) > 1:
                    print(file, ":", sep="")
                printFunc(createFileList(file))
        except FileNotFoundError as err:
            if moreThanOneArg: print()
            print(err)
            didErrorOccur = 1
        except PermissionError:
            if moreThanOneArg: print()
            print("{}: cannot open directory '{}': Permission denied".format(os.path.basename(sys.argv[0]), file))
            didErrorOccur = 1
        finally:
            moreThanOneArg = 1


def oneFilePerLine(list):
    for l in list:
        print(l)

def prettyPrint(list):
    """print files in table format"""
    maxlen = 0
    for f in list:
        if len(f) > maxlen:
            maxlen = len(f)
    # 2 for enclosing single qoutes, 2 for spaces after filename
    colWidth = maxlen + 4
    noOfCol = int(int(terminalColumnSize)/colWidth)
    if noOfCol == 0 or noOfCol == 1:
        for f in list:
            print("{!r}".format(f))
    else:
        nthCol=0
        for f in list:
            nthCol += 1
            print('{!r}'.format(f).ljust(colWidth), end="")
            if nthCol == noOfCol:
                print()
                nthCol=0
        if nthCol != noOfCol and nthCol != 0:
            print()
"""function declarations ENDS here"""


def main():
    global didErrorOccur
    version()
    if not len(args.files):
        """if no argument is given, assume it to be current directory"""
        args.files = ['.']
    if args.xargs:
        """if -x or --xargs is given, output string of null terminated file names"""
        try:
            print(xargsInput(), end="")
            sys.exit(0)
        except FileNotFoundError as err:
            print(err)
            sys.exit(2)
        except PermissionError as err:
            print(err)
            sys.exit(2)
    elif args.one:
        """output one file per line"""
        columnOutput(oneFilePerLine)
        pass
    else:
        """output file names in table format"""
        columnOutput(prettyPrint)


if __name__ == "__main__":
    didErrorOccur = 0 # used as a flag whether error occur or not
    main()
    if didErrorOccur:
        sys.exit(2)
    else:
        sys.exit(0)
